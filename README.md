# Minimal Next.js + Supabase site builder (assessment)

## Setup
1. Copy `.env.local.example` to `.env.local` and fill:
```
NEXT_PUBLIC_SUPABASE_URL=...
NEXT_PUBLIC_SUPABASE_ANON_KEY=...
```
2. Create tables and RLS in Supabase SQL editor:

```sql
-- profiles (one per user)
create table if not exists profiles (
  id uuid primary key references auth.users on delete cascade,
  username text unique not null,
  created_at timestamp with time zone default now()
);

-- pages (draft vs published in same row for simplicity)
create table if not exists pages (
  id bigint generated by default as identity primary key,
  owner_id uuid not null references profiles(id) on delete cascade,
  slug text not null,
  draft_title text,
  published_title text,
  updated_at timestamp with time zone default now(),
  published_at timestamp with time zone,
  unique(owner_id, slug)
);

alter table profiles enable row level security;
alter table pages enable row level security;

-- RLS policies
-- profiles: user can view own profile; public cannot list profiles; users can upsert their own row
create policy "profile owner can select" on profiles
  for select using (auth.uid() = id);
create policy "profile owner can upsert" on profiles
  for insert with check (auth.uid() = id);
create policy "profile owner can update" on profiles
  for update using (auth.uid() = id);

-- pages: only owner can edit any rows; anyone can select published rows
create policy "owner can manage their pages" on pages
  for all using (auth.uid() = owner_id) with check (auth.uid() = owner_id);
create policy "public can read published pages" on pages
  for select using (published_at is not null);
```

3. Run dev
```
npm run dev
```
Visit `/login`, then `/dashboard`, publish, and check `/web/{username}`.

## Answers (condensed)

### Database & RLS
- Tables: `sites` (id, owner_id, domain, settings), `pages` (site_id, slug, draft_json, published_json, draft_title, published_title, updated_at, published_at), `blocks` (page_id, order_index, draft_data, published_data), `media` (id, site_id, path, status: 'draft'|'published'). For this mini build, we co-locate draft and published in columns on `pages`.
- RLS: owner-only writes; public select where `published_at is not null`. Example above.

### Inline Editing & Blocks
- Editor: TipTap or Slate. I prefer TipTap for schema-driven rich text, extensions (mentions, links), collaboration, and good SSR handling; Slate is fine but more low-level. For very minimal text, `contentEditable` works (used here) but lacks structure/plugins.
- Store content as structured JSON (TipTap/Slate document) in `draft_json` columns; sanitize any HTML if storing HTML. Prevent XSS by never rendering raw user HTML without sanitization (DOMPurify on client, or sanitize/validate on server) and by using allow-lists when converting to HTML.

### Autosave & Optimistic Updates
- Optimistic UI: update local state immediately; debounce 300–800ms before upsert to `pages`. Use `on('postgres_changes')` channel for real-time sync across sessions. Track `updated_at` for conflict resolution (last-write-wins or vector clocks if needed).

### File Uploads & Security
- Buckets: `media-draft` (private), `media-published` (public). Upload to draft bucket with signed URLs for preview. On publish, server-side move/copy to public bucket and store public path. Alternatively, single private bucket with object ACLs and switch to public via policy on status flag.
- Policies or signed URLs: keep draft private with policies requiring `auth.uid() = site.owner_id`. For public: allow read where `metadata->>'visibility' = 'public'` or in a public bucket. Generate short-lived signed URLs for private previews.

### Custom Domains & SSL
- Use Vercel or Cloudflare. Flow: user adds custom domain; show CNAME to `cname.yourapp.com` and TXT for verification. Verify via DNS query + HTTP challenge. Provision SSL via provider (Vercel auto SSL, or Cloudflare SSL for SaaS, or Let's Encrypt via ACME if self-managed). Route traffic to your app and map host header to `site_id`.

### Publish Pipeline
- Copy draft → published in one transaction: for each page/block, set `published_*` fields from `draft_*`, move media from draft to public, set `published_at` and version tag. Keep drafts editable without affecting live site.

### Multi-Tenant Architecture
- Namespace by `site_id` and `owner_id`. All DB queries filter by current `site_id` or `owner_id`. Frontend routes like `/web/[username]` or `/s/[siteSlug]`. Use RLS to prevent cross-tenant access.

### SEO Metadata
- Use Next.js `generateMetadata` to fetch published data server-side and return dynamic `title`, `description`, `openGraph` fields. Avoid exposing drafts.

### Mini Practical Test
- Implemented: login page, dashboard with inline title editor and autosave, publish button, public route at `/web/[username]` that reads only published content with dynamic metadata.
